diff --git a/gdb/nat/windows-nat.h b/gdb/nat/windows-nat.h
index 84f6505e4c7..aaeedcc8ac1 100644
--- a/gdb/nat/windows-nat.h
+++ b/gdb/nat/windows-nat.h
@@ -19,7 +19,7 @@
 #ifndef NAT_WINDOWS_NAT_H
 #define NAT_WINDOWS_NAT_H
 
-#include <windows.h>
+#include "win32-thunk.h"
 #include <vector>
 
 #include "gdbsupport/gdb_optional.h"
diff --git a/gdb/ser-tcp.c b/gdb/ser-tcp.c
index 019aa4e52ec..f71684785f0 100644
--- a/gdb/ser-tcp.c
+++ b/gdb/ser-tcp.c
@@ -39,7 +39,7 @@
 #include "gdbsupport/gdb_sys_time.h"
 
 #ifdef USE_WIN32API
-#include <ws2tcpip.h>
+#include "win32-thunk.h"
 #ifndef ETIMEDOUT
 #define ETIMEDOUT WSAETIMEDOUT
 #endif
@@ -290,7 +290,7 @@ net_open (struct serial *scb, const char *name)
   if (parsed.port_str.empty ())
     error (_("Missing port on hostname '%s'"), name);
 
-  int r = getaddrinfo (parsed.host_str.c_str (),
+  int r = Win32Thunk::getaddrinfo (parsed.host_str.c_str (),
 		       parsed.port_str.c_str (),
 		       &hint, &ainfo);
 
diff --git a/gdb/win32-thunk.h b/gdb/win32-thunk.h
new file mode 100644
index 00000000000..949ed2705c4
--- /dev/null
+++ b/gdb/win32-thunk.h
@@ -0,0 +1,166 @@
+#pragma once
+
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <windows.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <type_traits>
+
+namespace Win32Thunk {
+  inline DWORD WINAPI GetConsoleProcessList(
+    LPDWORD lpdwProcessList,
+    DWORD dwProcessCount
+  ) {
+    using type = decltype(&::GetConsoleProcessList);
+    static type real = (type) GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetConsoleProcessList");
+    if (real)
+      return real(lpdwProcessList, dwProcessCount);
+
+    return 0;
+  }
+
+  inline UINT WINAPI GetSystemWow64DirectoryA(
+    LPSTR lpBuffer,
+    UINT uSize
+  ) {
+    using type = decltype(&::GetSystemWow64DirectoryA);
+    static type real = (type) GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetSystemWow64DirectoryA");
+    if (real)
+      return real(lpBuffer, uSize);
+
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return 0;
+  }
+
+  inline void WSAAPI freeaddrinfo(
+    _In_ PADDRINFOA pAddrInfo
+  ) {
+    using type = decltype(&::freeaddrinfo);
+    static type real = (type)GetProcAddress(GetModuleHandleW(L"ws2_32.dll"), "freeaddrinfo");
+    if (real)
+      return real(pAddrInfo);
+
+    while (pAddrInfo) {
+      addrinfo *next = pAddrInfo->ai_next;
+      free(pAddrInfo->ai_addr);
+      free(pAddrInfo);
+      pAddrInfo = next;
+    }
+  }
+
+  namespace Detail {
+    inline addrinfo *AddrInfoFromHostent(const hostent *host, int port, int idx) {
+      // this is the last entry
+      if (host->h_addr_list[idx] == nullptr)
+        return nullptr;
+
+      addrinfo *next = AddrInfoFromHostent(host, port, idx + 1);
+
+      addrinfo *result = (addrinfo *)malloc(sizeof(addrinfo));
+      if (!result) {
+        Win32Thunk::freeaddrinfo(next);
+        return nullptr;
+      }
+
+      result->ai_flags = 0;
+      result->ai_family = AF_INET;
+      result->ai_socktype = SOCK_STREAM;
+      result->ai_protocol = IPPROTO_TCP;
+      result->ai_canonname = nullptr;
+      result->ai_addrlen = sizeof(sockaddr_in);
+
+      sockaddr_in *addr = (sockaddr_in *)malloc(sizeof(sockaddr_in));
+      if (!addr) {
+        Win32Thunk::freeaddrinfo(result);
+        Win32Thunk::freeaddrinfo(next);
+        return nullptr;
+      }
+
+      addr->sin_family = AF_INET;
+      addr->sin_port = htons(port);
+      addr->sin_addr = *(in_addr *)host->h_addr_list[idx];
+      memset(addr->sin_zero, 0, sizeof(addr->sin_zero));
+      result->ai_addr = (sockaddr *)addr;
+
+      result->ai_next = next;
+      return result;
+    }
+  }
+
+  inline INT WSAAPI getaddrinfo(
+    _In_opt_ PCSTR pNodeName,
+    _In_opt_ PCSTR pServiceName,
+    _In_opt_ const ADDRINFOA *pHints,
+    _Out_ PADDRINFOA *ppResult
+  ) {
+    using type = decltype(&::getaddrinfo);
+    static type real = (type)GetProcAddress(GetModuleHandleW(L"ws2_32.dll"), "getaddrinfo");
+    if (real)
+      return real(pNodeName, pServiceName, pHints, ppResult);
+
+    if (!pNodeName)
+      return WSAHOST_NOT_FOUND;
+    if (pHints && pHints->ai_family != AF_UNSPEC)
+      return WSAEAFNOSUPPORT;
+
+    int port = 0;
+    if (pServiceName)
+      port = atoi(pServiceName);
+
+    struct hostent *host = gethostbyname(pNodeName);
+    if (!host)
+      return WSANO_DATA;
+
+    addrinfo *result = Detail::AddrInfoFromHostent(host, port, 0);
+    if (!result)
+      return WSA_NOT_ENOUGH_MEMORY;
+    *ppResult = result;
+    return 0;
+  }
+
+  inline INT WSAAPI getnameinfo(
+    _In_ const SOCKADDR *pSockaddr,
+    _In_ socklen_t SockaddrLength,
+    _Out_ PCHAR pNodeBuffer,
+    _In_ DWORD NodeBufferLength,
+    _Out_ PCHAR pServiceBuffer,
+    _In_ DWORD ServiceBufferLength,
+    _In_ INT Flags
+  ) {
+    using type = decltype(&::getnameinfo);
+    static type real = (type)GetProcAddress(GetModuleHandleW(L"ws2_32.dll"), "getnameinfo");
+    if (real)
+      return real(pSockaddr, SockaddrLength, pNodeBuffer, NodeBufferLength, pServiceBuffer, ServiceBufferLength, Flags);
+
+    if (pServiceBuffer && ServiceBufferLength > 0)
+      snprintf(pServiceBuffer, ServiceBufferLength, "%d", ntohs(((sockaddr_in *)pSockaddr)->sin_port));
+
+    if (SockaddrLength == sizeof(sockaddr_in)) {
+      const sockaddr_in *addr = (const sockaddr_in *)pSockaddr;
+      hostent *host = gethostbyaddr((const char *)&addr->sin_addr, sizeof(in_addr), AF_INET);
+      if (!host)
+        return WSANO_DATA;
+
+      if (pNodeBuffer && NodeBufferLength > 0) {
+        strncpy(pNodeBuffer, host->h_name, NodeBufferLength);
+        pNodeBuffer[NodeBufferLength - 1] = '\0';
+      }
+      return 0;
+    } else if (SockaddrLength == sizeof(sockaddr_in6)) {
+      const sockaddr_in6 *addr = (const sockaddr_in6 *)pSockaddr;
+      hostent *host = gethostbyaddr((const char *)&addr->sin6_addr, sizeof(in6_addr), AF_INET6);
+      if (!host)
+        return WSANO_DATA;
+
+      if (pNodeBuffer && NodeBufferLength > 0) {
+        strncpy(pNodeBuffer, host->h_name, NodeBufferLength);
+        pNodeBuffer[NodeBufferLength - 1] = '\0';
+      }
+      return 0;
+    } else {
+      return WSAEFAULT;
+    }
+  }
+}
diff --git a/gdb/windows-nat.c b/gdb/windows-nat.c
index 108e1e32edc..05c25c95587 100644
--- a/gdb/windows-nat.c
+++ b/gdb/windows-nat.c
@@ -1912,7 +1912,7 @@ windows_add_all_dlls (void)
     {
       /* This fails on 32bit Windows because it has no SysWOW64 directory,
 	 and in this case a path conversion isn't necessary.  */
-      UINT len = GetSystemWow64DirectoryA (syswow_dir, sizeof (syswow_dir));
+      UINT len = Win32Thunk::GetSystemWow64DirectoryA (syswow_dir, sizeof (syswow_dir));
       if (len > 0)
 	{
 	  /* Check that we have passed a large enough buffer.  */
diff --git a/gdbserver/gdbreplay.cc b/gdbserver/gdbreplay.cc
index 438a6a60bdb..5272533734e 100644
--- a/gdbserver/gdbreplay.cc
+++ b/gdbserver/gdbreplay.cc
@@ -53,7 +53,7 @@
 #endif
 
 #if USE_WIN32API
-#include <ws2tcpip.h>
+#include "win32-thunk.h"
 #endif
 
 #include "gdbsupport/netstuff.h"
@@ -192,7 +192,7 @@ remote_open (char *name)
     }
 #endif
 
-  int r = getaddrinfo (parsed.host_str.c_str (), parsed.port_str.c_str (),
+  int r = Win32Thunk::getaddrinfo (parsed.host_str.c_str (), parsed.port_str.c_str (),
 		       &hint, &ainfo);
 
   if (r != 0)
@@ -268,7 +268,7 @@ remote_open (char *name)
       setsockopt (remote_desc, IPPROTO_TCP, TCP_NODELAY,
 		  (char *) &tmp, sizeof (tmp));
 
-      if (getnameinfo ((struct sockaddr *) &sockaddr, sockaddrsize,
+      if (Win32Thunk::getnameinfo ((struct sockaddr *) &sockaddr, sockaddrsize,
 		       orig_host, sizeof (orig_host),
 		       orig_port, sizeof (orig_port),
 		       NI_NUMERICHOST | NI_NUMERICSERV) == 0)
diff --git a/gdbserver/remote-utils.cc b/gdbserver/remote-utils.cc
index 1195ce87ec7..0d102429a24 100644
--- a/gdbserver/remote-utils.cc
+++ b/gdbserver/remote-utils.cc
@@ -65,7 +65,7 @@
 #include <sys/stat.h>
 
 #if USE_WIN32API
-#include <ws2tcpip.h>
+#include "win32-thunk.h"
 #endif
 
 #ifndef HAVE_SOCKLEN_T
@@ -179,7 +179,7 @@ handle_accept_event (int err, gdb_client_data client_data)
   /* Convert IP address to string.  */
   char orig_host[GDB_NI_MAX_ADDR], orig_port[GDB_NI_MAX_PORT];
 
-  int r = getnameinfo ((struct sockaddr *) &sockaddr, len,
+  int r = Win32Thunk::getnameinfo ((struct sockaddr *) &sockaddr, len,
 		       orig_host, sizeof (orig_host),
 		       orig_port, sizeof (orig_port),
 		       NI_NUMERICHOST | NI_NUMERICSERV);
@@ -257,7 +257,7 @@ remote_prepare (const char *name)
     }
 #endif
 
-  int r = getaddrinfo (parsed.host_str.c_str (), parsed.port_str.c_str (),
+  int r = Win32Thunk::getaddrinfo (parsed.host_str.c_str (), parsed.port_str.c_str (),
 		       &hint, &ainfo);
 
   if (r != 0)
@@ -384,7 +384,7 @@ remote_open (const char *name)
       if (getsockname (listen_desc, (struct sockaddr *) &sockaddr, &len) < 0)
 	perror_with_name ("Can't determine port");
 
-      int r = getnameinfo ((struct sockaddr *) &sockaddr, len,
+      int r = Win32Thunk::getnameinfo ((struct sockaddr *) &sockaddr, len,
 			   NULL, 0,
 			   listen_port, sizeof (listen_port),
 			   NI_NUMERICSERV);
diff --git a/gdbsupport/netstuff.cc b/gdbsupport/netstuff.cc
index a056e6adf7d..246239ffcbd 100644
--- a/gdbsupport/netstuff.cc
+++ b/gdbsupport/netstuff.cc
@@ -21,7 +21,7 @@
 #include <algorithm>
 
 #ifdef USE_WIN32API
-#include <ws2tcpip.h>
+#include "win32-thunk.h"
 #else
 #include <netinet/in.h>
 #include <arpa/inet.h>
@@ -34,7 +34,7 @@
 
 scoped_free_addrinfo::~scoped_free_addrinfo ()
 {
-  freeaddrinfo (m_res);
+  Win32Thunk::freeaddrinfo (m_res);
 }
 
 /* See gdbsupport/netstuff.h.  */
